/*

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */
import java.io.Serializable;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.util.Arrays;

import static java.lang.String.format;

/**
 * Created by Rafael on 10/03/2018.
 *
 * @author Rafael
 * @since 10/03/2018
 */
public class Hashing {
    private static final HashFunction MURMUR3_128 = new Murmur3_128HashFunction(0);

    /**
     * Checks that the passed argument is positive, and ceils it to a multiple of 32.
     */
    private static int checkPositiveAndMakeMultipleOf32(int bits) {
        if (bits <= 0) throw new IllegalArgumentException("Number of bits must be positive");
        return (bits + 31) & ~31;
    }

    /**
     * Returns a general-purpose, <b>temporary-use</b>, non-cryptographic hash function. The algorithm
     * the returned function implements is unspecified and subject to change without notice.
     * <p>
     * <p><b>Warning:</b> a new random seed for these functions is chosen each time the {@code
     * Hashing} class is loaded. <b>Do not use this method</b> if hash codes may escape the current
     * process in any way, for example being sent over RPC, or saved to disk.
     * <p>
     * <p>Repeated calls to this method on the same loaded {@code Hashing} class, using the same value
     * for {@code minimumBits}, will return identically-behaving {@link HashFunction} instances.
     *
     * @param minimumBits a positive integer (can be arbitrarily large)
     * @return a hash function, described above, that produces hash codes of length {@code
     * minimumBits} or greater
     */
    public static HashFunction goodFastHash(int minimumBits) {
        int bits = checkPositiveAndMakeMultipleOf32(minimumBits);

        // Otherwise, join together some 128-bit murmur3s
        int hashFunctionsNeeded = (bits + 127) / 128;
        HashFunction[] hashFunctions = new HashFunction[hashFunctionsNeeded];
        hashFunctions[0] = MURMUR3_128;
        int seed = 0;
        for (int i = 1; i < hashFunctionsNeeded; i++) {
            seed += 1500450271; // a prime; shouldn't matter
            hashFunctions[i] = new Murmur3_128HashFunction(seed);
        }
        return new ConcatenatedHashFunction(hashFunctions);
    }

    private static final int UNSIGNED_MASK = 0xFF;

    /**
     * Returns the value of the given byte as an integer, when treated as unsigned. That is, returns
     * {@code value + 256} if {@code value} is negative; {@code value} itself otherwise.
     * <p>
     * <p><b>Java 8 users:</b> use {@link Byte#toUnsignedInt(byte)} instead.
     *
     * @since 6.0
     */
    public static int toInt(byte value) {
        return value & UNSIGNED_MASK;
    }

    /**
     * An object which can receive a stream of primitive values.
     *
     * @author Kevin Bourrillion
     * @since 12.0 (in 11.0 as {@code Sink})
     */
    public interface PrimitiveSink {
        /**
         * Puts a byte into this sink.
         *
         * @param b a byte
         * @return this instance
         */
        PrimitiveSink putByte(byte b);

        /**
         * Puts an array of bytes into this sink.
         *
         * @param bytes a byte array
         * @return this instance
         */
        PrimitiveSink putBytes(byte[] bytes);

        /**
         * Puts a chunk of an array of bytes into this sink. {@code bytes[off]} is the first byte written,
         * {@code bytes[off + len - 1]} is the last.
         *
         * @param bytes a byte array
         * @param off the start offset in the array
         * @param len the number of bytes to write
         * @return this instance
         * @throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length} or
         *     {@code len < 0}
         */
        PrimitiveSink putBytes(byte[] bytes, int off, int len);

        /**
         * Puts the remaining bytes of a byte buffer into this sink. {@code bytes.position()} is the first
         * byte written, {@code bytes.limit() - 1} is the last. The position of the buffer will be equal
         * to the limit when this method returns.
         *
         * @param bytes a byte buffer
         * @return this instance
         * @since 23.0
         */
        PrimitiveSink putBytes(ByteBuffer bytes);

        /** Puts a short into this sink. */
        PrimitiveSink putShort(short s);

        /** Puts an int into this sink. */
        PrimitiveSink putInt(int i);

        /** Puts a long into this sink. */
        PrimitiveSink putLong(long l);

        /** Puts a float into this sink. */
        PrimitiveSink putFloat(float f);

        /** Puts a double into this sink. */
        PrimitiveSink putDouble(double d);

        /** Puts a boolean into this sink. */
        PrimitiveSink putBoolean(boolean b);

        /** Puts a character into this sink. */
        PrimitiveSink putChar(char c);

        /**
         * Puts each 16-bit code unit from the {@link CharSequence} into this sink.
         *
         * <p><b>Warning:</b> This method will produce different output than most other languages do when
         * running on the equivalent input. For cross-language compatibility, use {@link #putString},
         * usually with a charset of UTF-8. For other use cases, use {@code putUnencodedChars}.
         *
         * @since 15.0 (since 11.0 as putString(CharSequence))
         */
        PrimitiveSink putUnencodedChars(CharSequence charSequence);

        /**
         * Puts a string into this sink using the given charset.
         *
         * <p><b>Warning:</b> This method, which reencodes the input before processing it, is useful only
         * for cross-language compatibility. For other use cases, prefer {@link #putUnencodedChars}, which
         * is faster, produces the same output across Java releases, and processes every {@code char} in
         * the input, even if some are invalid.
         */
        PrimitiveSink putString(CharSequence charSequence, Charset charset);
    }

    /**
     * A {@link PrimitiveSink} that can compute a hash code after reading the input. Each hasher should
     * translate all multibyte values ({@link #putInt(int)}, {@link #putLong(long)}, etc) to bytes in
     * little-endian order.
     *
     * <p><b>Warning:</b> The result of calling any methods after calling {@link #hash} is undefined.
     *
     * <p><b>Warning:</b> Using a specific character encoding when hashing a {@link CharSequence} with
     * {@link #putString(CharSequence, Charset)} is generally only useful for cross-language
     * compatibility (otherwise prefer {@link #putUnencodedChars}). However, the character encodings
     * must be identical across languages. Also beware that {@link Charset} definitions may occasionally
     * change between Java releases.
     *
     * <p><b>Warning:</b> Chunks of data that are put into the {@link Hasher} are not delimited. The
     * resulting {@link HashCode} is dependent only on the bytes inserted, and the order in which they
     * were inserted, not how those bytes were chunked into discrete put() operations. For example, the
     * following three expressions all generate colliding hash codes:
     *
     * <pre>{@code
     * newHasher().putByte(b1).putByte(b2).putByte(b3).hash()
     * newHasher().putByte(b1).putBytes(new byte[] { b2, b3 }).hash()
     * newHasher().putBytes(new byte[] { b1, b2, b3 }).hash()
     * }</pre>
     *
     * <p>If you wish to avoid this, you should either prepend or append the size of each chunk. Keep in
     * mind that when dealing with char sequences, the encoded form of two concatenated char sequences
     * is not equivalent to the concatenation of their encoded form. Therefore, {@link
     * #putString(CharSequence, Charset)} should only be used consistently with <i>complete</i>
     * sequences and not broken into chunks.
     *
     * @author Kevin Bourrillion
     * @since 11.0
     */
    public interface Hasher extends PrimitiveSink {
        @Override
        Hasher putByte(byte b);

        @Override
        Hasher putBytes(byte[] bytes);

        @Override
        Hasher putBytes(byte[] bytes, int off, int len);

        @Override
        Hasher putBytes(ByteBuffer bytes);

        @Override
        Hasher putShort(short s);

        @Override
        Hasher putInt(int i);

        @Override
        Hasher putLong(long l);

        /** Equivalent to {@code putInt(Float.floatToRawIntBits(f))}. */
        @Override
        Hasher putFloat(float f);

        /** Equivalent to {@code putLong(Double.doubleToRawLongBits(d))}. */
        @Override
        Hasher putDouble(double d);

        /** Equivalent to {@code putByte(b ? (byte) 1 : (byte) 0)}. */
        @Override
        Hasher putBoolean(boolean b);

        @Override
        Hasher putChar(char c);

        /**
         * Equivalent to processing each {@code char} value in the {@code CharSequence}, in order. In
         * other words, no character encoding is performed; the low byte and high byte of each {@code
         * char} are hashed directly (in that order). The input must not be updated while this method is
         * in progress.
         *
         * <p><b>Warning:</b> This method will produce different output than most other languages do when
         * running the same hash function on the equivalent input. For cross-language compatibility, use
         * {@link #putString}, usually with a charset of UTF-8. For other use cases, use {@code
         * putUnencodedChars}.
         *
         * @since 15.0 (since 11.0 as putString(CharSequence)).
         */
        @Override
        Hasher putUnencodedChars(CharSequence charSequence);

        /**
         * Equivalent to {@code putBytes(charSequence.toString().getBytes(charset))}.
         *
         * <p><b>Warning:</b> This method, which reencodes the input before hashing it, is useful only for
         * cross-language compatibility. For other use cases, prefer {@link #putUnencodedChars}, which is
         * faster, produces the same output across Java releases, and hashes every {@code char} in the
         * input, even if some are invalid.
         */
        @Override
        Hasher putString(CharSequence charSequence, Charset charset);

        /** A simple convenience for {@code funnel.funnel(object, this)}. */
        <T> Hasher putObject(T instance, Funnel<? super T> funnel);

        /**
         * Computes a hash code based on the data that have been provided to this hasher. The result is
         * unspecified if this method is called more than once on the same instance.
         */
        HashCode hash();

        /**
         * {@inheritDoc}
         *
         * @deprecated This returns {@link Object#hashCode()}; you almost certainly mean to call {@code
         *     hash().asInt()}.
         */
        @Override
        @Deprecated
        int hashCode();
    }

    /**
     * An object which can send data from an object of type {@code T} into a {@code PrimitiveSink}.
     * Implementations for common types can be found in {@code Funnels}.
     *
     * <p>Note that serialization of {@code BloomFilter bloom filters} requires the proper
     * serialization of funnels. When possible, it is recommended that funnels be implemented as a
     * single-element enum to maintain serialization guarantees. See Effective Java (2nd Edition), Item
     * 3: "Enforce the singleton property with a private constructor or an enum type". For example:
     *
     * <pre>{@code
     * public enum PersonFunnel implements Funnel<Person> {
     *   INSTANCE;
     *   public void funnel(Person person, PrimitiveSink into) {
     *     into.putUnencodedChars(person.getFirstName())
     *         .putUnencodedChars(person.getLastName())
     *         .putInt(person.getAge());
     *   }
     * }
     * }</pre>
     *
     * @author Dimitris Andreou
     * @since 11.0
     */
    public interface Funnel<T> extends Serializable {

        /**
         * Sends a stream of data from the {@code from} object into the sink {@code into}. There is no
         * requirement that this data be complete enough to fully reconstitute the object later.
         *
         * @since 12.0 (in Guava 11.0, {@code PrimitiveSink} was named {@code Sink})
         */
        void funnel(T from, PrimitiveSink into);
    }

    /**
     * An immutable hash code of arbitrary bit length.
     *
     * @author Dimitris Andreou
     * @author Kurt Alfred Kluever
     * @since 11.0
     */
    public static abstract class HashCode {
        HashCode() {}

        /** Returns the number of bits in this hash code; a positive multiple of 8. */
        public abstract int bits();

        /**
         * Returns the first four bytes of {@linkplain #asBytes() this hashcode's bytes}, converted to an
         * {@code int} value in little-endian order.
         *
         * @throws IllegalStateException if {@code bits() < 32}
         */
        public abstract int asInt();

        /**
         * Returns the first eight bytes of {@linkplain #asBytes() this hashcode's bytes}, converted to a
         * {@code long} value in little-endian order.
         *
         * @throws IllegalStateException if {@code bits() < 64}
         */
        public abstract long asLong();

        /**
         * If this hashcode has enough bits, returns {@code asLong()}, otherwise returns a {@code long}
         * value with {@code asBytes()} as the least-significant bytes and {@code 0x00} as the remaining
         * most-significant bytes.
         *
         * @since 14.0 (since 11.0 as {@code Hashing.padToLong(HashCode)})
         */
        public abstract long padToLong();

        /**
         * Returns the value of this hash code as a byte array. The caller may modify the byte array;
         * changes to it will <i>not</i> be reflected in this {@code HashCode} object or any other arrays
         * returned by this method.
         */
        // TODO(user): consider ByteString here, when that is available
        public abstract byte[] asBytes();

        /**
         * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
         * or string of size {@code size}, and are in order. A position index may range from zero to
         * {@code size}, inclusive.
         *
         * @param start a user-supplied index identifying a starting position in an array, list or string
         * @param end a user-supplied index identifying a ending position in an array, list or string
         * @param size the size of that array, list or string
         * @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},
         *     or if {@code end} is less than {@code start}
         * @throws IllegalArgumentException if {@code size} is negative
         */
        public static void checkPositionIndexes(int start, int end, int size) {
            // Carefully optimized for execution by hotspot (explanatory comment above)
            if (start < 0 || end < start || end > size) {
                throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));
            }
        }

        private static String badPositionIndex(int index, int size, String desc) {
            if (index < 0) {
                return format("%s (%s) must not be negative", desc, index);
            } else if (size < 0) {
                throw new IllegalArgumentException("negative size: " + size);
            } else { // index > size
                return format("%s (%s) must not be greater than size (%s)", desc, index, size);
            }
        }

        private static String badPositionIndexes(int start, int end, int size) {
            if (start < 0 || start > size) {
                return badPositionIndex(start, size, "start index");
            }
            if (end < 0 || end > size) {
                return badPositionIndex(end, size, "end index");
            }
            // end < start
            return format("end index (%s) must not be less than start index (%s)", end, start);
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * @param expression a boolean expression
         * @throws IllegalArgumentException if {@code expression} is false
         */
        public static void checkArgument(boolean expression) {
            if (!expression) {
                throw new IllegalArgumentException();
            }
        }

        /**
         * Returns the least value present in {@code array}.
         *
         * @param array a <i>nonempty</i> array of {@code int} values
         * @return the value present in {@code array} that is less than or equal to every other value in
         *     the array
         * @throws IllegalArgumentException if {@code array} is empty
         */
        public static int min(int... array) {
            checkArgument(array.length > 0);
            int min = array[0];
            for (int i = 1; i < array.length; i++) {
                if (array[i] < min) {
                    min = array[i];
                }
            }
            return min;
        }

        /**
         * Copies bytes from this hash code into {@code dest}.
         *
         * @param dest the byte array into which the hash code will be written
         * @param offset the start offset in the data
         * @param maxLength the maximum number of bytes to write
         * @return the number of bytes written to {@code dest}
         * @throws IndexOutOfBoundsException if there is not enough room in {@code dest}
         */
        public int writeBytesTo(byte[] dest, int offset, int maxLength) {
            maxLength = min(maxLength, bits() / 8);
            checkPositionIndexes(offset, offset + maxLength, dest.length);
            writeBytesToImpl(dest, offset, maxLength);
            return maxLength;
        }

        abstract void writeBytesToImpl(byte[] dest, int offset, int maxLength);

        /**
         * Returns a mutable view of the underlying bytes for the given {@code HashCode} if it is a
         * byte-based hashcode. Otherwise it returns {@link HashCode#asBytes}. Do <i>not</i> mutate this
         * array or else you will break the immutability contract of {@code HashCode}.
         */
        byte[] getBytesInternal() {
            return asBytes();
        }

        /**
         * Returns whether this {@code HashCode} and that {@code HashCode} have the same value, given that
         * they have the same number of bits.
         */
        abstract boolean equalsSameBits(HashCode that);

        /**
         * Creates a 32-bit {@code HashCode} representation of the given int value. The underlying bytes
         * are interpreted in little endian order.
         *
         * @since 15.0 (since 12.0 in HashCodes)
         */
        public static HashCode fromInt(int hash) {
            return new IntHashCode(hash);
        }

        private static final class IntHashCode extends HashCode implements Serializable {
            final int hash;

            IntHashCode(int hash) {
                this.hash = hash;
            }

            @Override
            public int bits() {
                return 32;
            }

            @Override
            public byte[] asBytes() {
                return new byte[] {(byte) hash, (byte) (hash >> 8), (byte) (hash >> 16), (byte) (hash >> 24)};
            }

            @Override
            public int asInt() {
                return hash;
            }

            @Override
            public long asLong() {
                throw new IllegalStateException("this HashCode only has 32 bits; cannot create a long");
            }

            static final long INT_MASK = 0xffffffffL;
            /**
             * Returns the value of the given {@code int} as a {@code long}, when treated as unsigned.
             *
             * <p><b>Java 8 users:</b> use {@link Integer#toUnsignedLong(int)} instead.
             */
            public static long toLong(int value) {
                return value & INT_MASK;
            }

            @Override
            public long padToLong() {
                return toLong(hash);
            }

            @Override
            void writeBytesToImpl(byte[] dest, int offset, int maxLength) {
                for (int i = 0; i < maxLength; i++) {
                    dest[offset + i] = (byte) (hash >> (i * 8));
                }
            }

            @Override
            boolean equalsSameBits(HashCode that) {
                return hash == that.asInt();
            }

            private static final long serialVersionUID = 0;
        }

        /**
         * Creates a 64-bit {@code HashCode} representation of the given long value. The underlying bytes
         * are interpreted in little endian order.
         *
         * @since 15.0 (since 12.0 in HashCodes)
         */
        public static HashCode fromLong(long hash) {
            return new LongHashCode(hash);
        }

        private static final class LongHashCode extends HashCode implements Serializable {
            final long hash;

            LongHashCode(long hash) {
                this.hash = hash;
            }

            @Override
            public int bits() {
                return 64;
            }

            @Override
            public byte[] asBytes() {
                return new byte[] {
                        (byte) hash,
                        (byte) (hash >> 8),
                        (byte) (hash >> 16),
                        (byte) (hash >> 24),
                        (byte) (hash >> 32),
                        (byte) (hash >> 40),
                        (byte) (hash >> 48),
                        (byte) (hash >> 56)
                };
            }

            @Override
            public int asInt() {
                return (int) hash;
            }

            @Override
            public long asLong() {
                return hash;
            }

            @Override
            public long padToLong() {
                return hash;
            }

            @Override
            void writeBytesToImpl(byte[] dest, int offset, int maxLength) {
                for (int i = 0; i < maxLength; i++) {
                    dest[offset + i] = (byte) (hash >> (i * 8));
                }
            }

            @Override
            boolean equalsSameBits(HashCode that) {
                return hash == that.asLong();
            }

            private static final long serialVersionUID = 0;
        }

        /**
         * Creates a {@code HashCode} from a byte array. The array is defensively copied to preserve the
         * immutability contract of {@code HashCode}. The array cannot be empty.
         *
         * @since 15.0 (since 12.0 in HashCodes)
         */
        public static HashCode fromBytes(byte[] bytes) {
            checkArgument(bytes.length >= 1, "A HashCode must contain at least 1 byte.");
            return fromBytesNoCopy(bytes.clone());
        }

        /**
         * Creates a {@code HashCode} from a byte array. The array is <i>not</i> copied defensively, so it
         * must be handed-off so as to preserve the immutability contract of {@code HashCode}.
         */
        static HashCode fromBytesNoCopy(byte[] bytes) {
            return new BytesHashCode(bytes);
        }

        private static final class BytesHashCode extends HashCode implements Serializable {
            final byte[] bytes;

            /**
             * Ensures that an object reference passed as a parameter to the calling method is not null.
             *
             * @param reference an object reference
             * @return the non-null reference that was validated
             * @throws NullPointerException if {@code reference} is null
             */
            public static <T> T checkNotNull(T reference) {
                if (reference == null) {
                    throw new NullPointerException();
                }
                return reference;
            }

            BytesHashCode(byte[] bytes) {
                this.bytes = checkNotNull(bytes);
            }

            @Override
            public int bits() {
                return bytes.length * 8;
            }

            @Override
            public byte[] asBytes() {
                return bytes.clone();
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * @param expression a boolean expression
             * @throws IllegalStateException if {@code expression} is false
             */
            public static void checkState(boolean expression) {
                if (!expression) {
                    throw new IllegalStateException();
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * @param expression a boolean expression
             * @param errorMessage the exception message to use if the check fails; will be converted to a
             *     string using {@link String#valueOf(Object)}
             * @throws IllegalStateException if {@code expression} is false
             */
            public static void checkState(boolean expression, Object errorMessage) {
                if (!expression) {
                    throw new IllegalStateException(String.valueOf(errorMessage));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * @param expression a boolean expression
             * @param errorMessageTemplate a template for the exception message should the check fail. The
             *     message is formed by replacing each {@code %s} placeholder in the template with an
             *     argument. These are matched by position - the first {@code %s} gets {@code
             *     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
             *     square braces. Unmatched placeholders will be left as-is.
             * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
             *     are converted to strings using {@link String#valueOf(Object)}.
             * @throws IllegalStateException if {@code expression} is false
             */
            public static void checkState(
                    boolean expression,
                    String errorMessageTemplate,
                    Object... errorMessageArgs) {
                if (!expression) {
                    throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(boolean b, String errorMessageTemplate, char p1) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(boolean b, String errorMessageTemplate, int p1) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(boolean b, String errorMessageTemplate, long p1) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, Object p1) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, char p1, char p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, char p1, int p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, char p1, long p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, char p1, Object p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, int p1, char p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, int p1, int p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, int p1, long p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, int p1, Object p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, long p1, char p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, long p1, int p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, long p1, long p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, long p1, Object p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, Object p1, char p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, Object p1, int p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b, String errorMessageTemplate, Object p1, long p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b,
                    String errorMessageTemplate,
                    Object p1,
                    Object p2) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b,
                    String errorMessageTemplate,
                    Object p1,
                    Object p2,
                    Object p3) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3));
                }
            }

            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             *
             * <p>See {@link #checkState(boolean, String, Object...)} for details.
             *
             * @since 20.0 (varargs overload since 2.0)
             */
            public static void checkState(
                    boolean b,
                    String errorMessageTemplate,
                    Object p1,
                    Object p2,
                    Object p3,
                    Object p4) {
                if (!b) {
                    throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3, p4));
                }
            }


            @Override
            public int asInt() {
                checkState(
                        bytes.length >= 4,
                        "HashCode#asInt() requires >= 4 bytes (it only has %s bytes).",
                        bytes.length);
                return (bytes[0] & 0xFF)
                        | ((bytes[1] & 0xFF) << 8)
                        | ((bytes[2] & 0xFF) << 16)
                        | ((bytes[3] & 0xFF) << 24);
            }

            @Override
            public long asLong() {
                checkState(
                        bytes.length >= 8,
                        "HashCode#asLong() requires >= 8 bytes (it only has %s bytes).",
                        bytes.length);
                return padToLong();
            }

            @Override
            public long padToLong() {
                long retVal = (bytes[0] & 0xFF);
                for (int i = 1; i < Math.min(bytes.length, 8); i++) {
                    retVal |= (bytes[i] & 0xFFL) << (i * 8);
                }
                return retVal;
            }

            @Override
            void writeBytesToImpl(byte[] dest, int offset, int maxLength) {
                System.arraycopy(bytes, 0, dest, offset, maxLength);
            }

            @Override
            byte[] getBytesInternal() {
                return bytes;
            }

            @Override
            boolean equalsSameBits(HashCode that) {
                // We don't use MessageDigest.isEqual() here because its contract does not guarantee
                // constant-time evaluation (no short-circuiting).
                if (this.bytes.length != that.getBytesInternal().length) {
                    return false;
                }

                boolean areEqual = true;
                for (int i = 0; i < this.bytes.length; i++) {
                    areEqual &= (this.bytes[i] == that.getBytesInternal()[i]);
                }
                return areEqual;
            }

            private static final long serialVersionUID = 0;
        }


        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * @param expression a boolean expression
         * @param errorMessage the exception message to use if the check fails; will be converted to a
         *     string using {@link String#valueOf(Object)}
         * @throws IllegalArgumentException if {@code expression} is false
         */
        public static void checkArgument(boolean expression, Object errorMessage) {
            if (!expression) {
                throw new IllegalArgumentException(String.valueOf(errorMessage));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * @param expression a boolean expression
         * @param errorMessageTemplate a template for the exception message should the check fail. The
         *     message is formed by replacing each {@code %s} placeholder in the template with an
         *     argument. These are matched by position - the first {@code %s} gets {@code
         *     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
         *     square braces. Unmatched placeholders will be left as-is.
         * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
         *     are converted to strings using {@link String#valueOf(Object)}.
         * @throws IllegalArgumentException if {@code expression} is false
         */
        public static void checkArgument(
                boolean expression,
                String errorMessageTemplate,
                Object... errorMessageArgs) {
            if (!expression) {
                throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(boolean b, String errorMessageTemplate, char p1) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(boolean b, String errorMessageTemplate, int p1) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(boolean b, String errorMessageTemplate, long p1) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, Object p1) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, char p1, char p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, char p1, int p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, char p1, long p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, char p1, Object p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, int p1, char p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, int p1, int p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, int p1, long p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, int p1, Object p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, long p1, char p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, long p1, int p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, long p1, long p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, long p1, Object p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, Object p1, char p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, Object p1, int p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b, String errorMessageTemplate, Object p1, long p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b,
                String errorMessageTemplate,
                Object p1,
                Object p2) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b,
                String errorMessageTemplate,
                Object p1,
                Object p2,
                Object p3) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3));
            }
        }

        /**
         * Ensures the truth of an expression involving one or more parameters to the calling method.
         *
         * <p>See {@link #checkArgument(boolean, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static void checkArgument(
                boolean b,
                String errorMessageTemplate,
                Object p1,
                Object p2,
                Object p3,
                Object p4) {
            if (!b) {
                throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3, p4));
            }
        }

        /**
         * Creates a {@code HashCode} from a hexadecimal ({@code base 16}) encoded string. The string must
         * be at least 2 characters long, and contain only valid, lower-cased hexadecimal characters.
         *
         * <p>This method accepts the exact format generated by {@link #toString}. If you require more
         * lenient {@code base 16} decoding, please use {@code com.google.common.io.BaseEncoding#decode}
         * (and pass the result to {@link #fromBytes}).
         *
         * @since 15.0
         */
        public static HashCode fromString(String string) {
            checkArgument(
                    string.length() >= 2, "input string (%s) must have at least 2 characters", string);
            checkArgument(
                    string.length() % 2 == 0,
                    "input string (%s) must have an even number of characters",
                    string);

            byte[] bytes = new byte[string.length() / 2];
            for (int i = 0; i < string.length(); i += 2) {
                int ch1 = decode(string.charAt(i)) << 4;
                int ch2 = decode(string.charAt(i + 1));
                bytes[i / 2] = (byte) (ch1 + ch2);
            }
            return fromBytesNoCopy(bytes);
        }

        private static int decode(char ch) {
            if (ch >= '0' && ch <= '9') {
                return ch - '0';
            }
            if (ch >= 'a' && ch <= 'f') {
                return ch - 'a' + 10;
            }
            throw new IllegalArgumentException("Illegal hexadecimal character: " + ch);
        }

        /**
         * Returns {@code true} if {@code object} is a {@link HashCode} instance with the identical byte
         * representation to this hash code.
         *
         * <p><b>Security note:</b> this method uses a constant-time (not short-circuiting) implementation
         * to protect against <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>.
         */
        @Override
        public final boolean equals(Object object) {
            if (object instanceof HashCode) {
                HashCode that = (HashCode) object;
                return bits() == that.bits() && equalsSameBits(that);
            }
            return false;
        }

        /**
         * Returns a "Java hash code" for this {@code HashCode} instance; this is well-defined (so, for
         * example, you can safely put {@code HashCode} instances into a {@code HashSet}) but is otherwise
         * probably not what you want to use.
         */
        @Override
        public final int hashCode() {
            // If we have at least 4 bytes (32 bits), just take the first 4 bytes. Since this is
            // already a (presumably) high-quality hash code, any four bytes of it will do.
            if (bits() >= 32) {
                return asInt();
            }
            // If we have less than 4 bytes, use them all.
            byte[] bytes = getBytesInternal();
            int val = (bytes[0] & 0xFF);
            for (int i = 1; i < bytes.length; i++) {
                val |= ((bytes[i] & 0xFF) << (i * 8));
            }
            return val;
        }

        /**
         * Returns a string containing each byte of {@link #asBytes}, in order, as a two-digit unsigned
         * hexadecimal number in lower case.
         *
         * <p>Note that if the output is considered to be a single hexadecimal number, this hash code's
         * bytes are the <i>big-endian</i> representation of that number. This may be surprising since
         * everything else in the hashing API uniformly treats multibyte values as little-endian. But this
         * format conveniently matches that of utilities such as the UNIX {@code md5sum} command.
         *
         * <p>To create a {@code HashCode} from its string representation, see {@link #fromString}.
         */
        @Override
        public final String toString() {
            byte[] bytes = getBytesInternal();
            StringBuilder sb = new StringBuilder(2 * bytes.length);
            for (byte b : bytes) {
                sb.append(hexDigits[(b >> 4) & 0xf]).append(hexDigits[b & 0xf]);
            }
            return sb.toString();
        }

        private static final char[] hexDigits = "0123456789abcdef".toCharArray();
    }

    /**
     * A hash function is a collision-averse pure function that maps an arbitrary block of data to a
     * number called a <i>hash code</i>.
     *
     * <h3>Definition</h3>
     *
     * <p>Unpacking this definition:
     *
     * <ul>
     *   <li><b>block of data:</b> the input for a hash function is always, in concept, an ordered byte
     *       array. This hashing API accepts an arbitrary sequence of byte and multibyte values (via
     *       {@link Hasher}), but this is merely a convenience; these are always translated into raw
     *       byte sequences under the covers.
     *   <li><b>hash code:</b> each hash function always yields hash codes of the same fixed bit length
     *       (given by {@link #bits}). For example, {@code Hashing#sha1} produces a 160-bit number,
     *       while {@code Hashing#murmur3_32()} yields only 32 bits. Because a {@code long} value is
     *       clearly insufficient to hold all hash code values, this API represents a hash code as an
     *       instance of {@link HashCode}.
     *   <li><b>pure function:</b> the value produced must depend only on the input bytes, in the order
     *       they appear. Input data is never modified. {@link HashFunction} instances should always be
     *       stateless, and therefore thread-safe.
     *   <li><b>collision-averse:</b> while it can't be helped that a hash function will sometimes
     *       produce the same hash code for distinct inputs (a "collision"), every hash function strives
     *       to <i>some</i> degree to make this unlikely. (Without this condition, a function that
     *       always returns zero could be called a hash function. It is not.)
     * </ul>
     *
     * <p>Summarizing the last two points: "equal yield equal <i>always</i>; unequal yield unequal
     * <i>often</i>." This is the most important characteristic of all hash functions.
     *
     * <h3>Desirable properties</h3>
     *
     * <p>A high-quality hash function strives for some subset of the following virtues:
     *
     * <ul>
     *   <li><b>collision-resistant:</b> while the definition above requires making at least <i>some</i>
     *       token attempt, one measure of the quality of a hash function is <i>how well</i> it succeeds
     *       at this goal. Important note: it may be easy to achieve the theoretical minimum collision
     *       rate when using completely <i>random</i> sample input. The true test of a hash function is
     *       how it performs on representative real-world data, which tends to contain many hidden
     *       patterns and clumps. The goal of a good hash function is to stamp these patterns out as
     *       thoroughly as possible.
     *   <li><b>bit-dispersing:</b> masking out any <i>single bit</i> from a hash code should yield only
     *       the expected <i>twofold</i> increase to all collision rates. Informally, the "information"
     *       in the hash code should be as evenly "spread out" through the hash code's bits as possible.
     *       The result is that, for example, when choosing a bucket in a hash table of size 2^8,
     *       <i>any</i> eight bits could be consistently used.
     *   <li><b>cryptographic:</b> certain hash functions such as {@code Hashing#sha512} are designed to
     *       make it as infeasible as possible to reverse-engineer the input that produced a given hash
     *       code, or even to discover <i>any</i> two distinct inputs that yield the same result. These
     *       are called <i>cryptographic hash functions</i>. But, whenever it is learned that either of
     *       these feats has become computationally feasible, the function is deemed "broken" and should
     *       no longer be used for secure purposes. (This is the likely eventual fate of <i>all</i>
     *       cryptographic hashes.)
     *   <li><b>fast:</b> perhaps self-explanatory, but often the most important consideration. We have
     *       published <a href="#noWeHaventYet">microbenchmark results</a> for many common hash
     *       functions.
     * </ul>
     *
     * <h3>Providing input to a hash function</h3>
     *
     * <p>The primary way to provide the data that your hash function should act on is via a {@link
     * Hasher}. Obtain a new hasher from the hash function using {@link #newHasher}, "push" the relevant
     * data into it using methods like {@link Hasher#putBytes(byte[])}, and finally ask for the {@code
     * HashCode} when finished using {@link Hasher#hash}. (See an {@linkplain #newHasher example} of
     * this.)
     *
     * <p>If all you want to hash is a single byte array, string or {@code long} value, there are
     * convenient shortcut methods defined directly on {@link HashFunction} to make this easier.
     *
     * <p>Hasher accepts primitive data types, but can also accept any Object of type {@code T} provided
     * that you implement a {@link Funnel}{@code <T>} to specify how to "feed" data from that object
     * into the function. (See {@linkplain Hasher#putObject an example} of this.)
     *
     * <p><b>Compatibility note:</b> Throughout this API, multibyte values are always interpreted in
     * <i>little-endian</i> order. That is, hashing the byte array {@code {0x01, 0x02, 0x03, 0x04}} is
     * equivalent to hashing the {@code int} value {@code 0x04030201}. If this isn't what you need,
     * methods such as {@link Integer#reverseBytes} and {@code Ints#toByteArray} will help.
     *
     * <h3>Relationship to {@link Object#hashCode}</h3>
     *
     * <p>Java's baked-in concept of hash codes is constrained to 32 bits, and provides no separation
     * between hash algorithms and the data they act on, so alternate hash algorithms can't be easily
     * substituted. Also, implementations of {@code hashCode} tend to be poor-quality, in part because
     * they end up depending on <i>other</i> existing poor-quality {@code hashCode} implementations,
     * including those in many JDK classes.
     *
     * <p>{@code Object.hashCode} implementations tend to be very fast, but have weak collision
     * prevention and <i>no</i> expectation of bit dispersion. This leaves them perfectly suitable for
     * use in hash tables, because extra collisions cause only a slight performance hit, while poor bit
     * dispersion is easily corrected using a secondary hash function (which all reasonable hash table
     * implementations in Java use). For the many uses of hash functions beyond data structures,
     * however, {@code Object.hashCode} almost always falls short -- hence this library.
     *
     * @author Kevin Bourrillion
     * @since 11.0
     */
    public interface HashFunction {
        /**
         * Begins a new hash code computation by returning an initialized, stateful {@code Hasher}
         * instance that is ready to receive data. Example:
         *
         * <pre>{@code
         * HashFunction hf = Hashing.md5();
         * HashCode hc = hf.newHasher()
         *     .putLong(id)
         *     .putBoolean(isActive)
         *     .hash();
         * }</pre>
         */
        Hasher newHasher();

        /**
         * Begins a new hash code computation as {@link #newHasher()}, but provides a hint of the expected
         * size of the input (in bytes). This is only important for non-streaming hash functions (hash
         * functions that need to buffer their whole input before processing any of it).
         */
        Hasher newHasher(int expectedInputSize);

        /**
         * Shortcut for {@code newHasher().putInt(input).hash()}; returns the hash code for the given
         * {@code int} value, interpreted in little-endian byte order. The implementation <i>might</i>
         * perform better than its longhand equivalent, but should not perform worse.
         *
         * @since 12.0
         */
        HashCode hashInt(int input);

        /**
         * Shortcut for {@code newHasher().putLong(input).hash()}; returns the hash code for the given
         * {@code long} value, interpreted in little-endian byte order. The implementation <i>might</i>
         * perform better than its longhand equivalent, but should not perform worse.
         */
        HashCode hashLong(long input);

        /**
         * Shortcut for {@code newHasher().putBytes(input).hash()}. The implementation <i>might</i>
         * perform better than its longhand equivalent, but should not perform worse.
         */
        HashCode hashBytes(byte[] input);

        /**
         * Shortcut for {@code newHasher().putBytes(input, off, len).hash()}. The implementation
         * <i>might</i> perform better than its longhand equivalent, but should not perform worse.
         *
         * @throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length} or
         *     {@code len < 0}
         */
        HashCode hashBytes(byte[] input, int off, int len);

        /**
         * Shortcut for {@code newHasher().putBytes(input).hash()}. The implementation <i>might</i>
         * perform better than its longhand equivalent, but should not perform worse.
         *
         * @since 23.0
         */
        HashCode hashBytes(ByteBuffer input);

        /**
         * Shortcut for {@code newHasher().putUnencodedChars(input).hash()}. The implementation
         * <i>might</i> perform better than its longhand equivalent, but should not perform worse. Note
         * that no character encoding is performed; the low byte and high byte of each {@code char} are
         * hashed directly (in that order).
         *
         * <p><b>Warning:</b> This method will produce different output than most other languages do when
         * running the same hash function on the equivalent input. For cross-language compatibility, use
         * {@link #hashString}, usually with a charset of UTF-8. For other use cases, use {@code
         * hashUnencodedChars}.
         *
         * @since 15.0 (since 11.0 as hashString(CharSequence)).
         */
        HashCode hashUnencodedChars(CharSequence input);

        /**
         * Shortcut for {@code newHasher().putString(input, charset).hash()}. Characters are encoded using
         * the given {@link Charset}. The implementation <i>might</i> perform better than its longhand
         * equivalent, but should not perform worse.
         *
         * <p><b>Warning:</b> This method, which reencodes the input before hashing it, is useful only for
         * cross-language compatibility. For other use cases, prefer {@link #hashUnencodedChars}, which is
         * faster, produces the same output across Java releases, and hashes every {@code char} in the
         * input, even if some are invalid.
         */
        HashCode hashString(CharSequence input, Charset charset);

        /**
         * Shortcut for {@code newHasher().putObject(instance, funnel).hash()}. The implementation
         * <i>might</i> perform better than its longhand equivalent, but should not perform worse.
         *
         * @since 14.0
         */
        <T> HashCode hashObject(T instance, Funnel<? super T> funnel);

        /**
         * Returns the number of bits (a multiple of 32) that each hash code produced by this hash
         * function has.
         */
        int bits();
    }

    /**
     * See MurmurHash3_x64_128 in <a href="http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp">the
     * C++ implementation</a>.
     *
     * @author Austin Appleby
     * @author Dimitris Andreou
     */
    final static class Murmur3_128HashFunction extends AbstractHashFunction implements Serializable {
        // TODO(user): when the shortcuts are implemented, update BloomFilterStrategies
        private final int seed;

        Murmur3_128HashFunction(int seed) {
            this.seed = seed;
        }

        @Override
        public int bits() {
            return 128;
        }

        @Override
        public Hasher newHasher() {
            return new Murmur3_128Hasher(seed);
        }

        @Override
        public String toString() {
            return "Hashing.murmur3_128(" + seed + ")";
        }

        @Override
        public boolean equals(Object object) {
            if (object instanceof Murmur3_128HashFunction) {
                Murmur3_128HashFunction other = (Murmur3_128HashFunction) object;
                return seed == other.seed;
            }
            return false;
        }

        @Override
        public int hashCode() {
            return getClass().hashCode() ^ seed;
        }


        /**
         * An abstract implementation of {@link Hasher}, which only requires subtypes to implement {@link
         * #putByte}. Subtypes may provide more efficient implementations, however.
         *
         * @author Dimitris Andreou
         */
        static abstract class AbstractHasher implements Hasher {
            @Override
            public final Hasher putBoolean(boolean b) {
                return putByte(b ? (byte) 1 : (byte) 0);
            }

            @Override
            public final Hasher putDouble(double d) {
                return putLong(Double.doubleToRawLongBits(d));
            }

            @Override
            public final Hasher putFloat(float f) {
                return putInt(Float.floatToRawIntBits(f));
            }

            @Override
            public Hasher putUnencodedChars(CharSequence charSequence) {
                for (int i = 0, len = charSequence.length(); i < len; i++) {
                    putChar(charSequence.charAt(i));
                }
                return this;
            }

            @Override
            public Hasher putString(CharSequence charSequence, Charset charset) {
                return putBytes(charSequence.toString().getBytes(charset));
            }

            @Override
            public Hasher putBytes(byte[] bytes) {
                return putBytes(bytes, 0, bytes.length);
            }

            /**
             * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
             * or string of size {@code size}, and are in order. A position index may range from zero to
             * {@code size}, inclusive.
             *
             * @param start a user-supplied index identifying a starting position in an array, list or string
             * @param end a user-supplied index identifying a ending position in an array, list or string
             * @param size the size of that array, list or string
             * @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},
             *     or if {@code end} is less than {@code start}
             * @throws IllegalArgumentException if {@code size} is negative
             */
            public static void checkPositionIndexes(int start, int end, int size) {
                // Carefully optimized for execution by hotspot (explanatory comment above)
                if (start < 0 || end < start || end > size) {
                    throw new IndexOutOfBoundsException(HashCode.badPositionIndexes(start, end, size));
                }
            }

            @Override
            public Hasher putBytes(byte[] bytes, int off, int len) {
                checkPositionIndexes(off, off + len, bytes.length);
                for (int i = 0; i < len; i++) {
                    putByte(bytes[off + i]);
                }
                return this;
            }

            @Override
            public Hasher putBytes(ByteBuffer b) {
                if (b.hasArray()) {
                    putBytes(b.array(), b.arrayOffset() + b.position(), b.remaining());
                    b.position(b.limit());
                } else {
                    for (int remaining = b.remaining(); remaining > 0; remaining--) {
                        putByte(b.get());
                    }
                }
                return this;
            }

            @Override
            public Hasher putShort(short s) {
                putByte((byte) s);
                putByte((byte) (s >>> 8));
                return this;
            }

            @Override
            public Hasher putInt(int i) {
                putByte((byte) i);
                putByte((byte) (i >>> 8));
                putByte((byte) (i >>> 16));
                putByte((byte) (i >>> 24));
                return this;
            }

            @Override
            public Hasher putLong(long l) {
                for (int i = 0; i < 64; i += 8) {
                    putByte((byte) (l >>> i));
                }
                return this;
            }

            @Override
            public Hasher putChar(char c) {
                putByte((byte) c);
                putByte((byte) (c >>> 8));
                return this;
            }

            @Override
            public <T> Hasher putObject(T instance, Funnel<? super T> funnel) {
                funnel.funnel(instance, this);
                return this;
            }
        }

        /**
         * A convenience base class for implementors of {@code Hasher}; handles accumulating data until an
         * entire "chunk" (of implementation-dependent length) is ready to be hashed.
         *
         * @author Kevin Bourrillion
         * @author Dimitris Andreou
         */
        // TODO(kevinb): this class still needs some design-and-document-for-inheritance love
        static abstract class AbstractStreamingHasher extends AbstractHasher {
            /** Buffer via which we pass data to the hash algorithm (the implementor) */
            private final ByteBuffer buffer;

            /** Number of bytes to be filled before process() invocation(s). */
            private final int bufferSize;

            /** Number of bytes processed per process() invocation. */
            private final int chunkSize;

            /**
             * Constructor for use by subclasses. This hasher instance will process chunks of the specified
             * size.
             *
             * @param chunkSize the number of bytes available per {@link #process(ByteBuffer)} invocation;
             *     must be at least 4
             */
            protected AbstractStreamingHasher(int chunkSize) {
                this(chunkSize, chunkSize);
            }

            /**
             * Constructor for use by subclasses. This hasher instance will process chunks of the specified
             * size, using an internal buffer of {@code bufferSize} size, which must be a multiple of {@code
             * chunkSize}.
             *
             * @param chunkSize the number of bytes available per {@link #process(ByteBuffer)} invocation;
             *     must be at least 4
             * @param bufferSize the size of the internal buffer. Must be a multiple of chunkSize
             */
            protected AbstractStreamingHasher(int chunkSize, int bufferSize) {
                // TODO(kevinb): check more preconditions (as bufferSize >= chunkSize) if this is ever public
                HashCode.checkArgument(bufferSize % chunkSize == 0);

                // TODO(user): benchmark performance difference with longer buffer
                // always space for a single primitive
                this.buffer = ByteBuffer.allocate(bufferSize + 7).order(ByteOrder.LITTLE_ENDIAN);
                this.bufferSize = bufferSize;
                this.chunkSize = chunkSize;
            }

            /** Processes the available bytes of the buffer (at most {@code chunk} bytes). */
            protected abstract void process(ByteBuffer bb);

            /**
             * This is invoked for the last bytes of the input, which are not enough to fill a whole chunk.
             * The passed {@code ByteBuffer} is guaranteed to be non-empty.
             *
             * <p>This implementation simply pads with zeros and delegates to {@link #process(ByteBuffer)}.
             */
            protected void processRemaining(ByteBuffer bb) {
                bb.position(bb.limit()); // move at the end
                bb.limit(chunkSize + 7); // get ready to pad with longs
                while (bb.position() < chunkSize) {
                    bb.putLong(0);
                }
                bb.limit(chunkSize);
                bb.flip();
                process(bb);
            }

            @Override
            public final Hasher putBytes(byte[] bytes, int off, int len) {
                return putBytesInternal(ByteBuffer.wrap(bytes, off, len).order(ByteOrder.LITTLE_ENDIAN));
            }

            @Override
            public final Hasher putBytes(ByteBuffer readBuffer) {
                ByteOrder order = readBuffer.order();
                try {
                    readBuffer.order(ByteOrder.LITTLE_ENDIAN);
                    return putBytesInternal(readBuffer);
                } finally {
                    readBuffer.order(order);
                }
            }

            private Hasher putBytesInternal(ByteBuffer readBuffer) {
                // If we have room for all of it, this is easy
                if (readBuffer.remaining() <= buffer.remaining()) {
                    buffer.put(readBuffer);
                    munchIfFull();
                    return this;
                }

                // First add just enough to fill buffer size, and munch that
                int bytesToCopy = bufferSize - buffer.position();
                for (int i = 0; i < bytesToCopy; i++) {
                    buffer.put(readBuffer.get());
                }
                munch(); // buffer becomes empty here, since chunkSize divides bufferSize

                // Now process directly from the rest of the input buffer
                while (readBuffer.remaining() >= chunkSize) {
                    process(readBuffer);
                }

                // Finally stick the remainder back in our usual buffer
                buffer.put(readBuffer);
                return this;
            }

            /*
             * Note: hashString(CharSequence, Charset) is intentionally not overridden.
             *
             * While intuitively, using CharsetEncoder to encode the CharSequence directly to the buffer (or
             * even to an intermediate buffer) should be considerably more efficient than potentially
             * copying the CharSequence to a String and then calling getBytes(Charset) on that String, in
             * reality there are optimizations that make the getBytes(Charset) approach considerably faster,
             * at least for commonly used charsets like UTF-8.
             */

            @Override
            public final Hasher putByte(byte b) {
                buffer.put(b);
                munchIfFull();
                return this;
            }

            @Override
            public final Hasher putShort(short s) {
                buffer.putShort(s);
                munchIfFull();
                return this;
            }

            @Override
            public final Hasher putChar(char c) {
                buffer.putChar(c);
                munchIfFull();
                return this;
            }

            @Override
            public final Hasher putInt(int i) {
                buffer.putInt(i);
                munchIfFull();
                return this;
            }

            @Override
            public final Hasher putLong(long l) {
                buffer.putLong(l);
                munchIfFull();
                return this;
            }

            @Override
            public final HashCode hash() {
                munch();
                buffer.flip();
                if (buffer.remaining() > 0) {
                    processRemaining(buffer);
                    buffer.position(buffer.limit());
                }
                return makeHash();
            }

            /**
             * Computes a hash code based on the data that have been provided to this hasher. This is called
             * after all chunks are handled with {@link #process} and any leftover bytes that did not make a
             * complete chunk are handled with {@link #processRemaining}.
             */
            protected abstract HashCode makeHash();

            // Process pent-up data in chunks
            private void munchIfFull() {
                if (buffer.remaining() < 8) {
                    // buffer is full; not enough room for a primitive. We have at least one full chunk.
                    munch();
                }
            }

            private void munch() {
                buffer.flip();
                while (buffer.remaining() >= chunkSize) {
                    // we could limit the buffer to ensure process() does not read more than
                    // chunkSize number of bytes, but we trust the implementations
                    process(buffer);
                }
                buffer.compact(); // preserve any remaining data that do not make a full chunk
            }
        }

        private static final class Murmur3_128Hasher extends AbstractStreamingHasher {
            private static final int CHUNK_SIZE = 16;
            private static final long C1 = 0x87c37b91114253d5L;
            private static final long C2 = 0x4cf5ad432745937fL;
            private long h1;
            private long h2;
            private int length;

            Murmur3_128Hasher(int seed) {
                super(CHUNK_SIZE);
                this.h1 = seed;
                this.h2 = seed;
                this.length = 0;
            }

            @Override
            protected void process(ByteBuffer bb) {
                long k1 = bb.getLong();
                long k2 = bb.getLong();
                bmix64(k1, k2);
                length += CHUNK_SIZE;
            }

            private void bmix64(long k1, long k2) {
                h1 ^= mixK1(k1);

                h1 = Long.rotateLeft(h1, 27);
                h1 += h2;
                h1 = h1 * 5 + 0x52dce729;

                h2 ^= mixK2(k2);

                h2 = Long.rotateLeft(h2, 31);
                h2 += h1;
                h2 = h2 * 5 + 0x38495ab5;
            }

            @Override
            protected void processRemaining(ByteBuffer bb) {
                long k1 = 0;
                long k2 = 0;
                length += bb.remaining();
                switch (bb.remaining()) {
                    case 15:
                        k2 ^= (long) toInt(bb.get(14)) << 48; // fall through
                    case 14:
                        k2 ^= (long) toInt(bb.get(13)) << 40; // fall through
                    case 13:
                        k2 ^= (long) toInt(bb.get(12)) << 32; // fall through
                    case 12:
                        k2 ^= (long) toInt(bb.get(11)) << 24; // fall through
                    case 11:
                        k2 ^= (long) toInt(bb.get(10)) << 16; // fall through
                    case 10:
                        k2 ^= (long) toInt(bb.get(9)) << 8; // fall through
                    case 9:
                        k2 ^= (long) toInt(bb.get(8)); // fall through
                    case 8:
                        k1 ^= bb.getLong();
                        break;
                    case 7:
                        k1 ^= (long) toInt(bb.get(6)) << 48; // fall through
                    case 6:
                        k1 ^= (long) toInt(bb.get(5)) << 40; // fall through
                    case 5:
                        k1 ^= (long) toInt(bb.get(4)) << 32; // fall through
                    case 4:
                        k1 ^= (long) toInt(bb.get(3)) << 24; // fall through
                    case 3:
                        k1 ^= (long) toInt(bb.get(2)) << 16; // fall through
                    case 2:
                        k1 ^= (long) toInt(bb.get(1)) << 8; // fall through
                    case 1:
                        k1 ^= (long) toInt(bb.get(0));
                        break;
                    default:
                        throw new AssertionError("Should never get here.");
                }
                h1 ^= mixK1(k1);
                h2 ^= mixK2(k2);
            }

            @Override
            public HashCode makeHash() {
                h1 ^= length;
                h2 ^= length;

                h1 += h2;
                h2 += h1;

                h1 = fmix64(h1);
                h2 = fmix64(h2);

                h1 += h2;
                h2 += h1;

                return HashCode.fromBytesNoCopy(
                        ByteBuffer.wrap(new byte[CHUNK_SIZE])
                                .order(ByteOrder.LITTLE_ENDIAN)
                                .putLong(h1)
                                .putLong(h2)
                                .array());
            }

            private static long fmix64(long k) {
                k ^= k >>> 33;
                k *= 0xff51afd7ed558ccdL;
                k ^= k >>> 33;
                k *= 0xc4ceb9fe1a85ec53L;
                k ^= k >>> 33;
                return k;
            }

            private static long mixK1(long k1) {
                k1 *= C1;
                k1 = Long.rotateLeft(k1, 31);
                k1 *= C2;
                return k1;
            }

            private static long mixK2(long k2) {
                k2 *= C2;
                k2 = Long.rotateLeft(k2, 33);
                k2 *= C1;
                return k2;
            }
        }

        private static final long serialVersionUID = 0L;
    }

    /**
     * Skeleton implementation of {@link HashFunction} in terms of {@link #newHasher()}.
     * <p>
     * <p>TODO(lowasser): make public
     */
    abstract static class AbstractHashFunction implements HashFunction {
        @Override
        public <T> HashCode hashObject(T instance, Funnel<? super T> funnel) {
            return newHasher().putObject(instance, funnel).hash();
        }

        @Override
        public HashCode hashUnencodedChars(CharSequence input) {
            int len = input.length();
            return newHasher(len * 2).putUnencodedChars(input).hash();
        }

        @Override
        public HashCode hashString(CharSequence input, Charset charset) {
            return newHasher().putString(input, charset).hash();
        }

        @Override
        public HashCode hashInt(int input) {
            return newHasher(4).putInt(input).hash();
        }

        @Override
        public HashCode hashLong(long input) {
            return newHasher(8).putLong(input).hash();
        }

        @Override
        public HashCode hashBytes(byte[] input) {
            return hashBytes(input, 0, input.length);
        }

        @Override
        public HashCode hashBytes(byte[] input, int off, int len) {
            HashCode.checkPositionIndexes(off, off + len, input.length);
            return newHasher(len).putBytes(input, off, len).hash();
        }

        @Override
        public HashCode hashBytes(ByteBuffer input) {
            return newHasher(input.remaining()).putBytes(input).hash();
        }

        @Override
        public Hasher newHasher(int expectedInputSize) {
            HashCode.checkArgument(
                    expectedInputSize >= 0, "expectedInputSize must be >= 0 but was %s", expectedInputSize);
            return newHasher();
        }
    }

    /**
     * An abstract composition of multiple hash functions. {@linkplain #newHasher()} delegates to the
     * {@code Hasher} objects of the delegate hash functions, and in the end, they are used by
     * {@linkplain #makeHash(Hasher[])} that constructs the final {@code HashCode}.
     *
     * @author Dimitris Andreou
     */
    abstract static class AbstractCompositeHashFunction extends AbstractHashFunction {

        @SuppressWarnings("Immutable") // array not modified after creation
        final HashFunction[] functions;

        AbstractCompositeHashFunction(HashFunction... functions) {
            for (HashFunction function : functions) {
                checkNotNull(function);
            }
            this.functions = functions;
        }


        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * @param reference an object reference
         * @return the non-null reference that was validated
         * @throws NullPointerException if {@code reference} is null
         */
        public static <T> T checkNotNull(T reference) {
            if (reference == null) {
                throw new NullPointerException();
            }
            return reference;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * @param reference an object reference
         * @param errorMessage the exception message to use if the check fails; will be converted to a
         *     string using {@link String#valueOf(Object)}
         * @return the non-null reference that was validated
         * @throws NullPointerException if {@code reference} is null
         */
        public static <T> T checkNotNull(T reference, Object errorMessage) {
            if (reference == null) {
                throw new NullPointerException(String.valueOf(errorMessage));
            }
            return reference;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * @param reference an object reference
         * @param errorMessageTemplate a template for the exception message should the check fail. The
         *     message is formed by replacing each {@code %s} placeholder in the template with an
         *     argument. These are matched by position - the first {@code %s} gets {@code
         *     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
         *     square braces. Unmatched placeholders will be left as-is.
         * @param errorMessageArgs the arguments to be substituted into the message template. Arguments
         *     are converted to strings using {@link String#valueOf(Object)}.
         * @return the non-null reference that was validated
         * @throws NullPointerException if {@code reference} is null
         */
        public static <T> T checkNotNull(
                T reference,
                String errorMessageTemplate,
                Object... errorMessageArgs) {
            if (reference == null) {
                throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));
            }
            return reference;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(T obj, String errorMessageTemplate, char p1) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(T obj, String errorMessageTemplate, int p1) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(T obj, String errorMessageTemplate, long p1) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, Object p1) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, char p1, char p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, char p1, int p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, char p1, long p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, char p1, Object p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, int p1, char p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, int p1, int p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, int p1, long p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, int p1, Object p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, long p1, char p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, long p1, int p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, long p1, long p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, long p1, Object p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, Object p1, char p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, Object p1, int p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj, String errorMessageTemplate, Object p1, long p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj,
                String errorMessageTemplate,
                Object p1,
                Object p2) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj,
                String errorMessageTemplate,
                Object p1,
                Object p2,
                Object p3) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3));
            }
            return obj;
        }

        /**
         * Ensures that an object reference passed as a parameter to the calling method is not null.
         *
         * <p>See {@link #checkNotNull(Object, String, Object...)} for details.
         *
         * @since 20.0 (varargs overload since 2.0)
         */
        public static <T> T checkNotNull(
                T obj,
                String errorMessageTemplate,
                Object p1,
                Object p2,
                Object p3,
                Object p4) {
            if (obj == null) {
                throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3, p4));
            }
            return obj;
        }

        /**
         * Constructs a {@code HashCode} from the {@code Hasher} objects of the functions. Each of them
         * has consumed the entire input and they are ready to output a {@code HashCode}. The order of the
         * hashers are the same order as the functions given to the constructor.
         */
        // this could be cleaner if it passed HashCode[], but that would create yet another array...
        /* protected */
        abstract HashCode makeHash(Hasher[] hashers);

        @Override
        public Hasher newHasher() {
            Hasher[] hashers = new Hasher[functions.length];
            for (int i = 0; i < hashers.length; i++) {
                hashers[i] = functions[i].newHasher();
            }
            return fromHashers(hashers);
        }

        @Override
        public Hasher newHasher(int expectedInputSize) {
            HashCode.checkArgument(expectedInputSize >= 0);
            Hasher[] hashers = new Hasher[functions.length];
            for (int i = 0; i < hashers.length; i++) {
                hashers[i] = functions[i].newHasher(expectedInputSize);
            }
            return fromHashers(hashers);
        }

        private Hasher fromHashers(final Hasher[] hashers) {
            return new Hasher() {
                @Override
                public Hasher putByte(byte b) {
                    for (Hasher hasher : hashers) {
                        hasher.putByte(b);
                    }
                    return this;
                }

                @Override
                public Hasher putBytes(byte[] bytes) {
                    for (Hasher hasher : hashers) {
                        hasher.putBytes(bytes);
                    }
                    return this;
                }

                @Override
                public Hasher putBytes(byte[] bytes, int off, int len) {
                    for (Hasher hasher : hashers) {
                        hasher.putBytes(bytes, off, len);
                    }
                    return this;
                }

                @Override
                public Hasher putBytes(ByteBuffer bytes) {
                    int pos = bytes.position();
                    for (Hasher hasher : hashers) {
                        bytes.position(pos);
                        hasher.putBytes(bytes);
                    }
                    return this;
                }

                @Override
                public Hasher putShort(short s) {
                    for (Hasher hasher : hashers) {
                        hasher.putShort(s);
                    }
                    return this;
                }

                @Override
                public Hasher putInt(int i) {
                    for (Hasher hasher : hashers) {
                        hasher.putInt(i);
                    }
                    return this;
                }

                @Override
                public Hasher putLong(long l) {
                    for (Hasher hasher : hashers) {
                        hasher.putLong(l);
                    }
                    return this;
                }

                @Override
                public Hasher putFloat(float f) {
                    for (Hasher hasher : hashers) {
                        hasher.putFloat(f);
                    }
                    return this;
                }

                @Override
                public Hasher putDouble(double d) {
                    for (Hasher hasher : hashers) {
                        hasher.putDouble(d);
                    }
                    return this;
                }

                @Override
                public Hasher putBoolean(boolean b) {
                    for (Hasher hasher : hashers) {
                        hasher.putBoolean(b);
                    }
                    return this;
                }

                @Override
                public Hasher putChar(char c) {
                    for (Hasher hasher : hashers) {
                        hasher.putChar(c);
                    }
                    return this;
                }

                @Override
                public Hasher putUnencodedChars(CharSequence chars) {
                    for (Hasher hasher : hashers) {
                        hasher.putUnencodedChars(chars);
                    }
                    return this;
                }

                @Override
                public Hasher putString(CharSequence chars, Charset charset) {
                    for (Hasher hasher : hashers) {
                        hasher.putString(chars, charset);
                    }
                    return this;
                }

                @Override
                public <T> Hasher putObject(T instance, Funnel<? super T> funnel) {
                    for (Hasher hasher : hashers) {
                        hasher.putObject(instance, funnel);
                    }
                    return this;
                }

                @Override
                public HashCode hash() {
                    return makeHash(hashers);
                }
            };
        }

        private static final long serialVersionUID = 0L;
    }

    private static final class ConcatenatedHashFunction extends AbstractCompositeHashFunction {
        private final int bits;

        private ConcatenatedHashFunction(HashFunction... functions) {
            super(functions);
            int bitSum = 0;
            for (HashFunction function : functions) {
                bitSum += function.bits();
                HashCode.checkArgument(
                        function.bits() % 8 == 0,
                        "the number of bits (%s) in hashFunction (%s) must be divisible by 8",
                        function.bits(),
                        function);
            }
            this.bits = bitSum;
        }

        @Override
        HashCode makeHash(Hasher[] hashers) {
            byte[] bytes = new byte[bits / 8];
            int i = 0;
            for (Hasher hasher : hashers) {
                HashCode newHash = hasher.hash();
                i += newHash.writeBytesTo(bytes, i, newHash.bits() / 8);
            }
            return HashCode.fromBytesNoCopy(bytes);
        }

        @Override
        public int bits() {
            return bits;
        }

        @Override
        public boolean equals(Object object) {
            if (object instanceof ConcatenatedHashFunction) {
                ConcatenatedHashFunction other = (ConcatenatedHashFunction) object;
                return Arrays.equals(functions, other.functions);
            }
            return false;
        }

        @Override
        public int hashCode() {
            return Arrays.hashCode(functions) * 31 + bits;
        }
    }
}
